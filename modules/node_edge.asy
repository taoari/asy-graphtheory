import wt_style;

// edge
struct edge{
  node start=new node;
  node end=new node;
  path g=nullpath;
  Label L="";
  drawstyle style=copy(defaultdrawstyle);

  void draw(picture pic=currentpicture) 
  // { draw(pic, L, g, style.align, style.p, style.arrow, style.bar,
      // style.margin, style.legend, style.marker); } 
  { sdraw(L, g, style); }
  edge label(Label L) { this.L=L; return this; }
  edge l(Label L)=label;
  edge style(drawstyle sty) 
  { this.style=sty; return this; }
  edge style(labelstyle style) 
  { this.style.sL=style; return this; }
  edge style(align align=NoAlign, pen p=currentpen, arrowbar arrow=None,
      arrowbar bar=None, margin margin=NoMargin, marker marker=nomarker,
      pen lp=nullpen, embed embed=Rotate, filltype filltype=NoFill,
      string s)
  {
    // self define
    if(s=="leftside") this.style.align=LeftSide;
    else if(s=="rightside") this.style.align=RightSide;
    else if(s=="dashed") this.style.p+dashed;
    else if(s=="solid") this.style.p+solid;
    else if(s=="autorot") this.L.embed=Rotate(end.pos-start.pos);
    // drawstyle
    else if(s=="align") this.style.align=align;
    else if(s=="p") this.style.p=p;
    else if(s=="arrow") this.style.arrow=arrow;
    else if(s=="bar") this.style.bar=bar;
    else if(s=="margin") this.style.margin=margin;
    else if(s=="marker") this.style.marker=marker;
    // labelstyle
    else if(s=="lp") this.L.p=lp;
    else if(s=="embed") this.L.embed=embed;
    else if(s=="filltype") this.L.filltype=filltype;
    else abort("edge.style(): unrecognized string");
    return this;
  }
  edge style(align align=NoAlign, pen p=currentpen, arrowbar arrow=None,
      arrowbar bar=None, margin margin=NoMargin, marker marker=nomarker,
      pen lp=nullpen, embed embed=Rotate, filltype filltype=NoFill
      ... string[] strarr)
  {
    for (string s: strarr)
      style(align, p, arrow, bar, margin,
	  marker, lp, embed, filltype, s);
    return this;
  }
  edge shorten(real pre=0, real post=2) {
    this.g=subpath(this.g, arctime(this.g,pre), arctime(this.g, arclength(this.g)-post));
    return this;
  }
};

// draw
void draw(edge[] ea)
{
  for (edge e: ea)
    e.draw();
}

void draw(... edge[] ea)
{
  draw(ea);
}

// edges
struct edges{
  edge[] es;
  void draw()
  {
    for (edge e: es)
      e.draw();
  }
};
edges operator^^(edge e1, edge e2)
{
  edges es;
  es.es.push(e1);
  es.es.push(e2);
  return es;
}
edges operator^^(edges es1, edge e2)
{
  edges es;
  es.es=es1.es;
  es.es.push(e2);
  return es;
}
edges rest(... edge[] ea)
{
  edges es;
  es.es=ea;
  return es;
}
// compatablilty
path operator cast(edge e)
{
  return e.g;
}
path[] operator cast(edges es)
{
  path [] parr;
  for (edge e: es.es)
    parr.push(e.g);
  return parr;
}
// connect nodes with a line
edge operator--(node nd1, node nd2)
{
  edge e;
  e.start=nd1;
  e.end=nd2;
  pair c1=nd1.pos;
  pair c2=nd2.pos;
  path g1=shift(nd1.pos)*nd1.outline;
  path g2=shift(nd2.pos)*nd2.outline;
  path g = c1--c2;
  g=firstcut(g, g1).after;
  e.g=lastcut(g, g2).before;
  return e;
}

// edgeconnector typedef
typedef edge edgeconnector(node nd1, node nd2);
// function type generated by one node
typedef edge edgemaker(node nd);

// edgeconnector for curve
// first half of  nd1..con..nd2
edgemaker operator..(node nd, edgeconnector con)
{
  return new edge(node nd2)
  {
    return con(nd, nd2);
  };
}
// last half of nd1..con..nd2
edge operator..(edgemaker maker, node nd)
{
  return maker(nd);
}
// for nd1..loop(dir)
edge operator..(node nd, edgemaker maker)
{
  return maker(nd);
}
// edgeconnector for line
// first half of  nd1--con--nd2
edgemaker operator--(node nd, edgeconnector con)
{
  return new edge(node nd2)
  {
    return con(nd, nd2);
  };
}
// last half of nd1--con--nd2
edge operator--(edgemaker maker, node nd)
{
  return maker(nd);
}

// edgeconnector definition for curves
// edgeconnector for two nodes with a bended curve
edgeconnector bend(real ang)
{
  return new edge(node nd1, node nd2)
  {
    edge e;
    e.start=nd1;
    e.end=nd2;
    pair c1=nd1.pos;
    pair c2=nd2.pos;
    real deg=degrees(c2-c1);
    e.g=nd1.angle(deg-ang){dir(deg-ang)}
    ..{dir(deg+ang)}nd2.angle(180+deg+ang);
    return e;
  };
}

edgeconnector bendright=bend(30);
edgeconnector bendleft=bend(-30);
edgeconnector bend=bendright;

// edgemaker for loop
edgemaker loop(pair direction, real ang=60, real ratio=1.5)
{
  return new edge(node nd)
  {
    edge e;
    e.start=nd;
    e.end=nd;
    real deg=degrees(direction);
    real ang1=deg-ang/2, ang2=deg+ang/2;
    pair mid=nd.angle(deg)
      +ratio*fontsize(currentpen)*unit(direction);
    e.g=nd.angle(ang1){dir(ang1)}..mid
      ..{-dir(ang2)}nd.angle(ang2);
    return e;
  };
}

// edgeconnector definition for lines
edge HV(node nd1, node nd2)
{
  edge e;
  e.start=nd1;
  e.end=nd2;
  path g1=shift(nd1.pos)*nd1.outline;
  path g2=shift(nd2.pos)*nd2.outline;
  pair c1=nd1.pos;
  pair c2=nd2.pos;
  path g = c1--(c2.x,c1.y)--c2;
  g=firstcut(g, g1).after;
  e.g=lastcut(g, g2).before;
  return e;
}

edge VH(node nd1, node nd2)
{
  edge e;
  e.start=nd1;
  e.end=nd2;
  path g1=shift(nd1.pos)*nd1.outline;
  path g2=shift(nd2.pos)*nd2.outline;
  pair c1=nd1.pos;
  pair c2=nd2.pos;
  path g = c1--(c1.x,c2.y)--c2;
  g=firstcut(g, g1).after;
  e.g=lastcut(g, g2).before;
  return e;
}

edgeconnector HVH(real f, bool rel=true)
{
  return new edge(node nd1, node nd2)
  {
    edge e;
    e.start=nd1;
    e.end=nd2;
    path g1=shift(nd1.pos)*nd1.outline;
    path g2=shift(nd2.pos)*nd2.outline;
    pair c1=nd1.pos;
    pair c2=nd2.pos;
    pair D=c2-c1;
    if (rel)
    {
      if (D.x>0) { c1=nd1.dir(E); c2=nd2.dir(W); }
      else { c1=nd1.dir(W); c2=nd2.dir(E); }
    }
    real xmid=(1-f)*c1.x+f*c2.x;
    path g = c1--(xmid, c1.y)--(xmid, c2.y)--c2;
    g=lastcut(g, g1).after;
    e.g=firstcut(g, g2).before;
    return e;
  };
}

edgeconnector VHV(real f, bool rel=true)
{
  return new edge(node nd1, node nd2)
  {
    edge e;
    e.start=nd1;
    e.end=nd2;
    path g1=shift(nd1.pos)*nd1.outline;
    path g2=shift(nd2.pos)*nd2.outline;
    pair c1=nd1.pos;
    pair c2=nd2.pos;
    pair D=c2-c1;
    if (rel)
    {
      if (D.y>0) { c1=nd1.dir(N); c2=nd2.dir(S); }
      else { c1=nd1.dir(S); c2=nd2.dir(N); }
    }
    real ymid=(1-f)*c1.y+f*c2.y;
    path g = c1--(c1.x,ymid)--(c2.x,ymid)--c2;
    g=lastcut(g, g1).after;
    e.g=firstcut(g, g2).before;
    return e;
  };
}

edgeconnector HVH=HVH(0.5);
edgeconnector VHV=VHV(0.5);

edgeconnector HVHd(real f, bool rel=true)
{
  return new edge(node nd1, node nd2)
  {
    edge e;
    e.start=nd1;
    e.end=nd2;
    path g1=shift(nd1.pos)*nd1.outline;
    path g2=shift(nd2.pos)*nd2.outline;
    pair c1=nd1.pos;
    pair c2=nd2.pos;
    pair D=c2-c1;
    if (rel)
    {
      if (D.x>0) { c1=nd1.dir(E); c2=nd2.dir(W); }
      else { c1=nd1.dir(W); c2=nd2.dir(E); }
    }
    real xmid = (D.x>=0) ? c1.x+f : c1.x-f;
    path g = c1--(xmid, c1.y)--(xmid, c2.y)--c2;
    g=lastcut(g, g1).after;
    e.g=firstcut(g, g2).before;
    return e;
  };
}

edgeconnector VHVd(real f, bool rel=true)
{
  return new edge(node nd1, node nd2)
  {
    edge e;
    e.start=nd1;
    e.end=nd2;
    path g1=shift(nd1.pos)*nd1.outline;
    path g2=shift(nd2.pos)*nd2.outline;
    pair c1=nd1.pos;
    pair c2=nd2.pos;
    pair D=c2-c1;
    if (rel)
    {
      if (D.y>0) { c1=nd1.dir(N); c2=nd2.dir(S); }
      else { c1=nd1.dir(S); c2=nd2.dir(N); }
    }
    real ymid =  D.y>=0 ? c1.y+f : c1.y-f;
    path g = c1--(c1.x,ymid)--(c2.x,ymid)--c2;
    g=lastcut(g, g1).after;
    e.g=firstcut(g, g2).before;
    return e;
  };
}
// function on edge
typedef edge fedge(edge);

edge operator@(edge e, fedge t)
{
  return t(e);
}

// fedge: shorten
fedge shorten(real pre, real post)
{
  return new edge(edge e)
  {
    e.g=subpath(e.g, arctime(e.g,pre), arctime(e.g, arclength(e.g)-post));
    return e;
  };
}

fedge shorten=shorten(0,2);

